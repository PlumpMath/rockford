index.html

{% for item in me %}
<div class="col-sm-4">
                        <div class="list-group">
                            <a href="{{item.id}}" class="list-group-item active">{{item.ref_code|de-keyword}}</a>
				{% for sample in item.samples %}
                            <a href="{{sample.id}}" class="list-group-item">{{sample.sample_name}}</a>
				   {% endfor %}
                        </div>
                    </div>
{% endfor %}

; What I discovered tonight is that the top level passed to a Selmer for loop has to be a keyword
; You can't just start with a vector and do a "for map in 0" sort of thing
; Also, that you never have to refer to the vector using an 0 in the for loop
; The fact that it's a collection is apparently implicit

(ns rockford.handler
  (:require [compojure.core :refer :all]
            [compojure.route :as route]
            [ring.middleware.defaults :refer [wrap-defaults site-defaults]]
            [selmer.parser :as selmer]
            [selmer.filters :as f]))

(f/add-filter! :de-keyword name)

(def spresso [{:id 20 :ref_code :HBVDNA} {:id 30 :ref_code :HIVRNA}])

(def lookup {:HBVDNA [{:id 20 :sample_name "HBVDNA15-01"} {:id 21 :sample_name "HBVDNA15-02"}] 
                :HIVRNA [{:id 22 :sample_name "HIVRNA15-01"} {:id 23 :sample_name "HIVRNA15-02"}]})

(def sample-map (map #(assoc % :samples (get lookup (get % :ref_code))) spresso))

(defn selmer-page
  [request]
  (selmer/render-file "index.html" {:me sample-map}))
  
                 <!-- Toggle buttons to appear post-submit -->
               
                <div class="row">
                	<div class="col-lg-12">
                	<h2>Select drug resistance sites</h2>
                	
                	<div class="row">
                    <div class="col-lg-12">
                        <ul class="list-group">
                            
                	{% for c in codons %}
                			<li class="list-group-item">
                			
                			{% for i in c %}
                			
                			<button type="button" class="btn btn-primary">
                			<input type="checkbox" name="codon" id="codon_{{i}}" value="codon_{{i}}"> Codon {{i}}
                			</button>
					
							{% endfor %}
							
							</li>
					
					{% endfor %}
					</ul>
					</div>
                	</div>
                </div>
                </div>
                
                <!-- Toggle -->
                
  (let [parsed-params (-> params 
                        (merge {:start-codon (bji/parse-int (:start-codon params))
                                :end-codon (bji/parse-int (:end-codon params))}))]
                                
 :codons (partition-all 10 (range 1 200))
 
 (defn validate-reference-for-form-old
  [{:keys [params]}]
  (let [int-params (merge params
                     (reduce-kv #(assoc %1 %2 (bji/parse-int %3)) {} 
                                (select-keys params [:start-codon :end-codon])))
        errs-then-fasta (-> params file-to-fasta (check-max-fastas 1))
        errs-only (if (empty? (first errs-then-fasta)) nil (first errs-then-fasta))
        int-codons (select-keys int-params [:start-codon :end-codon])
        codon-counter (count-reference-codons (merge int-codons (second errs-then-fasta)))]
    (if-let [errors (merge-with #(reduce conj %1 %2) (validate-reference-form int-params) (codon-ordering-validation int-params) errs-only codon-counter)]
      (-> (response/found "/")
      (assoc :flash (assoc int-params :errors errors)))
     (save-reference! int-params 
                     (db/insert-reference! (merge (second errs-then-fasta) int-codons))))))